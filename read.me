Порівняння жадібного алгоритму та алгоритму динамічного програмування
Жадібний алгоритм (find_coins_greedy)
Жадібний алгоритм працює, вибираючи найбільші доступні номінали монет для видачі решти. Він ітеративно віднімає найбільший можливий номінал від суми, доки сума не стане нульовою.

Часова складність
Часова складність: O(n), де n — кількість доступних номіналів монет.
Продуктивність: Дуже ефективний для великих сум, оскільки кількість ітерацій залежить від кількості номіналів, а не від самої суми.
Переваги та недоліки
Переваги:
Простота реалізації.
Висока швидкість роботи.
Недоліки:
Не завжди знаходить оптимальне рішення (мінімальну кількість монет), особливо якщо набір монет не канонічний.
Алгоритм динамічного програмування (find_min_coins)
Алгоритм динамічного програмування шукає мінімальну кількість монет, необхідних для досягнення заданої суми. Він будує рішення знизу вгору, зберігаючи мінімальну кількість монет для всіх сум від 0 до заданої.

Часова складність
Часова складність: O(amount * n), де amount — сума, яку потрібно видати, n — кількість номіналів монет.
Продуктивність: При великих сумах час виконання може значно збільшуватися, оскільки алгоритм повинен обробити всі суми від 1 до amount.
Переваги та недоліки
Переваги:
Завжди знаходить оптимальне рішення з мінімальною кількістю монет.
Недоліки:
Більш складний у реалізації.
Може бути повільним для великих сум через високу часову складність.
Висновки
Жадібний алгоритм є більш ефективним з точки зору часу виконання, особливо для великих сум, оскільки його часова складність не залежить від значення суми.
Алгоритм динамічного програмування забезпечує оптимальне рішення, але його продуктивність може страждати при великих значеннях суми через лінійну залежність від amount.
Рекомендації
Якщо набір монет канонічний (як у нашому випадку), і жадібний алгоритм завжди знаходить оптимальне рішення, то варто використовувати жадібний алгоритм для підвищення продуктивності.
Якщо набір монет не канонічний, і є ймовірність, що жадібний алгоритм не знайде оптимальне рішення, слід використовувати алгоритм динамічного програмування.